<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>osu! — Artistic Gradient Pop</title>

<!-- JSZip (client-side unzip) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<style>
  :root{
    --muted: rgba(255,255,255,0.75);
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#fff; background: #0b0420; overflow:hidden; transition: background .7s ease;}
  /* stage & dropper */
  .stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px;box-sizing:border-box}
  .dropper{
    width:100%;
    max-width:980px;
    border-radius:18px;
    padding:36px;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:28px;
    flex-direction:column;
    text-align:center;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    box-shadow:0 12px 40px rgba(0,0,0,0.55);
    border: 1px solid rgba(255,255,255,0.04);
    transition:transform .28s cubic-bezier(.2,.9,.3,1), box-shadow .28s, opacity .28s;
    z-index: 40;
    backdrop-filter: blur(2px);
  }
  .dropper.drag{transform:translateY(-6px); box-shadow:0 18px 60px rgba(0,0,0,0.65); border-color: rgba(255,120,190,0.6)}
  .dropper.minimize{
    transform: translateY(-30px) scale(.95);
    opacity: 0;
    pointer-events: none;
  }

  .logo{width:76px;height:76px;border-radius:16px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ff77ff,#77a1ff);box-shadow:0 10px 30px rgba(0,0,0,0.45)}
  h1{margin:0;font-size:20px;letter-spacing:0.2px}
  p.lead{margin:0;color:var(--muted);font-size:13px}
  input[type=file]{display:none}
  .hint{margin-top:8px;color:var(--muted);font-size:13px}

  /* preview image */
  .previewWrap{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
    z-index:20;
    transition:opacity .35s ease;
  }
  .previewImg{
    max-width:78vmin;
    max-height:78vmin;
    width:auto;height:auto;
    border-radius:14px;
    box-shadow: 0 30px 90px rgba(0,0,0,0.6);
    transform:translateY(0);
    opacity:0;
    pointer-events:auto;
    background: rgba(255,255,255,0.02);
    object-fit:cover;
  }

  /* pop animation (spring) */
  .pop-in{
    animation: popIn 560ms cubic-bezier(.2,1.1,.3,1) forwards;
  }
  @keyframes popIn {
    0% { transform: translateY(18px) scale(.78); opacity: 0; filter: blur(4px); }
    60% { transform: translateY(-6px) scale(1.06); opacity: 1; filter: blur(0); }
    100% { transform: translateY(0) scale(1); opacity: 1; filter: blur(0); }
  }

  .smallStatus{
    position:fixed;left:18px;bottom:18px;color:var(--muted);font-size:13px;background:var(--glass);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);z-index:50
  }

  /* ARTISTIC BACKGROUND LAYERS */
  /* each layer is a full-screen fixed element behind UI (negative z-index) */
  .artist-bg,
  .conic-bg,
  .vignette {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: -5;
    will-change: transform, opacity;
  }

  /* the radial bursts layer (soft color blobs) */
  .artist-bg {
    filter: blur(48px) saturate(120%);
    opacity: 0;
    transform: scale(1.12);
    transition: opacity .7s ease, transform 900ms cubic-bezier(.2,.9,.3,1);
    mix-blend-mode: screen;
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
  }

  /* conic layer (rotating) */
  .conic-bg {
    opacity: 0;
    transform: rotate(8deg) scale(1.05);
    transition: opacity .85s ease;
    background-repeat: no-repeat;
    mix-blend-mode: overlay;
    filter: blur(20px) contrast(1.05) saturate(120%);
  }

  /* subtle vignette & ground */
  .vignette {
    background: radial-gradient(1200px 600px at 50% 55%, rgba(0,0,0,0.0) 0%, rgba(0,0,0,0.26) 65%, rgba(0,0,0,0.55) 100%);
    opacity: 0;
    transition: opacity .85s ease;
    z-index: -4;
  }

  /* when we reveal the art, set classes to animate */
  .artist-bg.revealed { opacity: 1; transform: scale(1); }
  .conic-bg.revealed  { opacity: .85; animation: spinSlow 28s linear infinite; }
  .vignette.revealed  { opacity: 1; }

  @keyframes spinSlow {
    from { transform: rotate(0deg) scale(1.05); }
    to   { transform: rotate(360deg) scale(1.05); }
  }

  /* small responsive adjustments */
  @media (max-width:720px){
    .dropper{padding:22px;border-radius:14px}
    .logo{width:64px;height:64px}
  }
</style>
</head>
<body>
  <!-- Artistic background layers -->
  <div id="artistBg" class="artist-bg" aria-hidden="true"></div>
  <div id="conicBg" class="conic-bg" aria-hidden="true"></div>
  <div id="vignette" class="vignette" aria-hidden="true"></div>

  <div class="stage">
    <div id="dropper" class="dropper" role="region" aria-label="Drop .osz here">
      <div class="logo" aria-hidden>
        <svg width="44" height="44" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.22)" stroke-width="1.2"/>
          <path d="M7 12.75V7.5h10v5.25" stroke="white" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      <h1 id="title">osu! — drop an .osz</h1>
      <p class="lead">Drop an .osz (or click). The first image will pop and reveal an artistic gradient background.</p>
      <div class="hint">Click to select a file or drop it here</div>
      <input id="file" type="file" accept=".osz,.zip" />
    </div>
  </div>

  <div id="previewWrap" class="previewWrap" style="display:none;pointer-events:none">
    <img id="previewImage" class="previewImg" src="" alt="preview" />
  </div>

  <div id="status" class="smallStatus" style="display:none">loading…</div>

<script>
/* Artistic background generator
   - builds layered radial blobs + conic gradient from server colors
   - reveals with animations (artist-style 'pop up' look)
   - preserves pop-in image & dropper behavior from previous version
*/

const MAX_SERVER_BYTES = 2 * 1024 * 1024;
const dropper = document.getElementById('dropper');
const fileInput = document.getElementById('file');
const title = document.getElementById('title');
const previewWrap = document.getElementById('previewWrap');
const previewImage = document.getElementById('previewImage');
const statusEl = document.getElementById('status');

const artistBg = document.getElementById('artistBg');
const conicBg  = document.getElementById('conicBg');
const vignette = document.getElementById('vignette');

let currentObjectUrl = null;
let pendingColors = null;
let gradientApplied = false;

function setStatus(txt, show=true){
  statusEl.textContent = txt || '';
  statusEl.style.display = show ? '' : 'none';
}

function clearPreview(){
  if(currentObjectUrl){ URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }
  previewImage.src = '';
  previewWrap.style.display = 'none';
  previewImage.classList.remove('pop-in');
}

async function handleFile(file){
  setStatus('reading archive…');
  clearArt(); // reset prior art
  try {
    if(!/\.osz$|\.zip$/i.test(file.name)) {
      throw new Error('Please provide a .osz (zip) file.');
    }
    const jszip = new JSZip();
    const z = await jszip.loadAsync(file);
    const keys = Object.keys(z.files);
    let chosenEntry = null;
    for(const k of keys){
      const e = z.files[k];
      if(e.dir) continue;
      if(/\.(jpe?g|png)$/i.test(k)) { chosenEntry = e; break; }
    }
    if(!chosenEntry) throw new Error('No image (.jpg/.png) found in archive.');
    const blob = await chosenEntry.async('blob');

    // preview image locally
    clearPreview();
    currentObjectUrl = URL.createObjectURL(blob);
    previewImage.src = currentObjectUrl;
    previewWrap.style.display = '';

    // small delay then pop
    await new Promise(r=>setTimeout(r, 40));
    previewImage.classList.add('pop-in');
    setTimeout(()=> dropper.classList.add('minimize'), 140);

    // concurrently send to server
    setStatus('preparing image…');
    const sendBlob = await ensureUnderLimit(blob, MAX_SERVER_BYTES);
    setStatus('rendering…');
    postImageAndReceive(sendBlob).catch(err=>{
      console.error(err);
      setStatus('render failed', true);
      setTimeout(()=> setStatus('', false), 1600);
    });

    // after pop ends, if pendingColors exist apply them
    const onAnim = () => {
      previewImage.removeEventListener('animationend', onAnim);
      if(pendingColors && !gradientApplied){
        revealArt(pendingColors);
      }
    };
    previewImage.addEventListener('animationend', onAnim);

    setStatus('waiting for render…');
  } catch (err) {
    console.error(err);
    clearPreview();
    setStatus(err.message || 'Error', true);
    setTimeout(()=> setStatus('', false), 3200);
  }
}

async function postImageAndReceive(blobToSend){
  try {
    const res = await fetch('/render', {
      method: 'POST',
      headers: {'Content-Type':'application/octet-stream'},
      body: blobToSend
    });
    if(!res.ok){
      const txt = await res.text().catch(()=>null) || ('server returned ' + res.status);
      throw new Error(txt);
    }
    const json = await res.json();
    if(!json || !Array.isArray(json.controlColors)) throw new Error('Invalid response from server');
    pendingColors = json.controlColors.slice();
    // if pop already finished or long fallback, reveal now
    setTimeout(()=>{
      if(!gradientApplied && previewImage.classList.contains('pop-in')===false){
        revealArt(pendingColors);
      }
    }, 500);
  } catch (err) {
    throw err;
  } finally {
    setStatus('', false);
  }
}

/* build art:
   - radial layer: several radial-gradient blobs positioned around the screen
   - conic layer: conic-gradient using colors
   blends + blur + subtle animations create an artist feel
*/
function buildArtistBackground(colors){
  // safe fallback
  if(!colors || colors.length===0) return { radial:'', conic:'' };

  // positions to cycle through (nice spread)
  const positions = ['12% 28%','85% 18%','22% 76%','78% 72%','50% 38%'];
  // blob sizes (large)
  const sizes = [ '680px 480px', '520px 420px', '780px 560px', '620px 480px', '520px 420px' ];

  // create radial blobs (soft stops)
  const radialParts = colors.map((c,i) => {
    const pos = positions[i % positions.length];
    const size = sizes[i % sizes.length];
    // softer center, then transparent; adjust alpha for pleasant mix
    return `radial-gradient(circle ${size} at ${pos}, ${c} 0%, ${hexToRgba(c,0.65)} 18%, ${hexToRgba(c,0.18)} 36%, rgba(0,0,0,0) 65%)`;
  });

  // add a subtle very-large low-opacity overlay (a wash)
  radialParts.push(`radial-gradient(circle 1400px at 50% 40%, ${hexToRgba(colors[0],0.16)} 0%, rgba(0,0,0,0) 45%)`);

  // conic: spin of colors for motion
  const conic = `conic-gradient(from 120deg at 50% 50%, ${colors.join(', ')})`;

  return { radial: radialParts.join(', '), conic };
}

function revealArt(colors){
  if(gradientApplied) return;
  gradientApplied = true;

  const { radial, conic } = buildArtistBackground(colors);

  // set radial background into artistBg
  artistBg.style.backgroundImage = radial;
  // set conic gradient (slightly transparent) into conicBg with blend
  conicBg.style.backgroundImage = conic;
  conicBg.style.opacity = '0.9';

  // reveal with classes (animations from CSS)
  requestAnimationFrame(()=> {
    artistBg.classList.add('revealed');
    conicBg.classList.add('revealed');
    vignette.classList.add('revealed');
  });

  // small tint to body fallback color (subtle)
  try {
    document.body.style.transition = 'background 700ms ease';
    const first = colors[0] || '#000000';
    // darken slightly for base tone
    document.body.style.background = hexToRgba(first, 0.06);
  } catch(e){}

  title.textContent = 'Drop another .osz to change';
}

/* reset art (when starting new) */
function clearArt(){
  gradientApplied = false;
  pendingColors = null;
  artistBg.classList.remove('revealed');
  conicBg.classList.remove('revealed');
  vignette.classList.remove('revealed');
  // clear backgrounds after short delay so transitions play
  setTimeout(()=>{
    artistBg.style.backgroundImage = '';
    conicBg.style.backgroundImage = '';
  }, 700);
  // bring dropper back
  dropper.classList.remove('minimize');
  title.textContent = 'osu! — drop an .osz';
}

/* helpers: ensureUnderLimit, dataURLToBlob (same as previous) */
async function ensureUnderLimit(blob, limit){
  if(blob.size <= limit) return blob;
  const img = new Image();
  img.crossOrigin = 'anonymous';
  const url = URL.createObjectURL(blob);
  img.src = url;
  await img.decode().catch(()=>{});
  URL.revokeObjectURL(url);

  const maxWidth = 1200;
  let w = img.naturalWidth, h = img.naturalHeight;
  if(w > maxWidth) {
    const ratio = maxWidth / w;
    w = Math.round(w * ratio);
    h = Math.round(h * ratio);
  }
  const canvas = document.createElement('canvas');
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0, w, h);

  let quality = 0.92;
  for(let attempt=0; attempt<6; attempt++){
    const dataUrl = canvas.toDataURL('image/jpeg', quality);
    const resizedBlob = dataURLToBlob(dataUrl);
    if(resizedBlob.size <= limit) return resizedBlob;
    quality -= 0.12;
    if(quality < 0.4) break;
  }
  const fallbackUrl = canvas.toDataURL('image/jpeg', Math.max(0.4, quality));
  return dataURLToBlob(fallbackUrl);
}
function dataURLToBlob(dataurl) {
  const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n);
  while(n--) u8arr[n] = bstr.charCodeAt(n);
  return new Blob([u8arr], {type:mime});
}

/* convert hex like #RRGGBB to rgba(...) with alpha */
function hexToRgba(hex, alpha){
  // handle #rgb / #rrggbb
  if(!hex) return `rgba(0,0,0,${alpha})`;
  const h = hex.replace('#','');
  let r,g,b;
  if(h.length===3){
    r = parseInt(h[0]+h[0],16);
    g = parseInt(h[1]+h[1],16);
    b = parseInt(h[2]+h[2],16);
  } else {
    r = parseInt(h.substring(0,2),16);
    g = parseInt(h.substring(2,4),16);
    b = parseInt(h.substring(4,6),16);
  }
  return `rgba(${r},${g},${b},${alpha})`;
}

/* main flow: same drop/pop/render as before */
dropper.addEventListener('dragover', (e)=>{ e.preventDefault(); dropper.classList.add('drag'); });
dropper.addEventListener('dragleave', ()=> dropper.classList.remove('drag'));
dropper.addEventListener('drop', (e)=> {
  e.preventDefault();
  dropper.classList.remove('drag');
  const dt = e.dataTransfer;
  if(dt && dt.files && dt.files.length) handleFile(dt.files[0]);
});

dropper.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', (e)=> {
  const f = e.target.files && e.target.files[0];
  if(f) handleFile(f);
  fileInput.value = '';
});

// cleanup object URL on unload
window.addEventListener('beforeunload', ()=>{
  try{ if(currentObjectUrl) URL.revokeObjectURL(currentObjectUrl); }catch(e){}
});
</script>
</body>
</html>
